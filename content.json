{"meta":{"title":"李雨","subtitle":null,"description":"个人技术文章集合","author":"Li Yu","url":"http://www.betterliyu.site"},"pages":[{"title":"","date":"2018-06-01T03:58:56.306Z","updated":"2018-06-01T03:58:56.306Z","comments":true,"path":"index.html","permalink":"http://www.betterliyu.site/index.html","excerpt":"","text":"You can access blog page!."},{"title":"test","date":"2018-06-01T09:04:11.694Z","updated":"2018-06-01T09:04:11.694Z","comments":true,"path":"test.html","permalink":"http://www.betterliyu.site/test.html","excerpt":"","text":""},{"title":"","date":"2018-05-29T09:53:20.430Z","updated":"2018-05-29T09:53:20.430Z","comments":true,"path":"404.html","permalink":"http://www.betterliyu.site/404.html","excerpt":"","text":"404 Oops! You're lost. We can not find the page you're looking for. Return home or try the search bar below."},{"title":"About Me","date":"2015-11-16T17:00:51.000Z","updated":"2018-01-22T01:53:57.315Z","comments":true,"path":"about/index.html","permalink":"http://www.betterliyu.site/about/index.html","excerpt":"","text":""},{"title":"Projects","date":"2015-11-29T13:00:03.000Z","updated":"2018-01-22T01:53:57.315Z","comments":true,"path":"projects/index.html","permalink":"http://www.betterliyu.site/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS学习笔记(一): Hello CSS","slug":"CSS学习笔记-一-Hello CSS","date":"2017-11-07T10:43:05.000Z","updated":"2018-05-25T02:47:34.146Z","comments":true,"path":"2017/11/07/CSS学习笔记-一-Hello CSS/","link":"","permalink":"http://www.betterliyu.site/2017/11/07/CSS学习笔记-一-Hello CSS/","excerpt":"","text":"内联样式内联样式定义在HTML标签的style属性中。除了在body外的标签，style属性可以定义在任何一个HTML标签中。1&lt;div style=\"color: red;font-size: 14px;\"&gt;文字&lt;/div&gt; 这样定义的样式只作用于这个div，不会影响到div以外的内容。内联style属性中只能放CSS样式规则大括号之内的键值对，也不能包含@import指令。通常不推荐使用内联样式，如果这样做的话会使HTML变得混乱，会使CSS灵活性大大的降低。 style标签也可以使用style标签定义样式。它以HTML标签的形式出现在head标签内。12345678910&lt;style type=\"text/css\"&gt; body &#123; color: red; &#125; div &#123; font-size: 14px; &#125; &lt;/style&gt; 这样定义的样式作用于全局，标签内定义的样式可以称为文档样式表。其中可以包含多组样式，也可以使用@import指令包含多个样式表链接。 属性 type: 表示类型，一般值为text/css，描述加载的数据类型，浏览器通过这个属性识别样式表是CSS样式表 media: 定义当前样式应用的媒体类型，下一章详细说明 link标签link标签用来引用外部样式表，应该优先考虑使用。 index.html1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"sheet1.css\" title=\"Default\"&gt; sheet1.css 1234567body &#123; color: red; &#125; div &#123; font-size: 14px;&#125; 这样定义的样式是一个独立的外部文件，通过link标签可以应用到当前的文档中。link标签必须是head标签的子元素。外部样式表中不能包含除CSS规则和CSS注释以外的任何标记，如果出现，会导致部分CSS规则会被忽略。外部样式一般以.css为文件名后缀，也不是必须的。但是一些老版本的浏览器无法识别包含样式表的文件，除非以.css为扩展名。 属性常见的link标签的属性有rel，type，href和media等。这里主要说明和样式相关的属性和属性值。 relrel属性表示外部文件和当前文档的关系，值通常设置为stylesheet，表示外部文件是样式表。除了stylesheet，rel属性还有其他可选值。 值 描述 alternate 链接到该文档的替代版本（例如打印页、翻译或镜像） author 链接到该文档的作者。 help 链接到帮助文档。 icon 表示该文档的图标。 licence 链接到该文档的版权信息。 next 集合中的下一个文档。 pingback 指向 pingback 服务器的 URL。 prefetch 规定应该对目标文档进行缓存。 prev 集合中的前一个文档。 search 链接到针对文档的搜索工具。 sidebar 链接到应该显示在浏览器侧栏的文档。 stylesheet 指向要导入的样式表的 URL。 tag 描述当前文档的标签（关键词）。 这里要特地说明的是alternate，可以利用这一属性设置网页候选样式1&lt;link rel=\"alternate stylesheet\" type=\"text/css\" href=\"sheet1.css\" title=\"Default\"&gt; 像上面的代码一样，设置rel=&quot;alternate stylesheet&quot;，同时设置title属性，就会有一个主题为Default的候选样式供选择。大多数Geckco内核的浏览器支持这一功能，你可以在火狐浏览器“查看&gt;页面样式”菜单中找到。title属性是全局属性，每个标签都可以定义，但是定义在link标签中则表示样式的主题，也可以定义多个同一主题文件。 typetype属性表示类型文件，值通常为text/css，描述加载的文件类型，浏览器通过这个属性识别样式表是CSS样式表。 hrefhref属性表示样式文件的URL，可以是绝对路径也可以是相对路径。 hreflanghreflang属性表示链接文档的语言类型。 mediamedia属性表示当前样式将要应用到什么样的媒体设备上。它的值需要符合媒体查询列表的格式。现代Web浏览器主要支持媒体类型的值主要是all，screen和print，在全屏模式中，Opera 也支持 projection属性值。12&lt;!-- 表示在屏幕设备上应用该样式，其他媒体类型无效 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"sheet1.css\" media=\"screen\"&gt; 也可以设置多个值12&lt;!-- 表示在屏幕设备上和打印时应用该样式，其他媒体类型无效 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"sheet1.css\" media=\"screen, print\"&gt; all表示所有设备都使用该样式，其他不常用的值有： aural：用于语音合成器，屏幕阅读器和文档的其他声音表现 braille：用Braille设备表现文档时使用 embossed：用Braille打印设备打印时使用 handheld：用于手持设备，如个人数字助理或支持Web的蜂窝电话 projection：用于投影媒体 tty：在固定间距环境中（如电传打字机）显示文档时使用 tv：在电视上显示文档时使用 HTML5之后，这个属性可以设置更多的值，值必须是media query list。参照CSS3的媒体查询。12&lt;!-- 表示在屏幕设备上和打印时应用该样式，其他媒体类型无效 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"sheet1.css\" media=\"screen, print\"&gt; 可能的操作符 值 描述 and 规定 AND 操作符 not 规定 NOT 操作符 , 规定 OR 操作符 设备 值 描述 all 默认。适用于所有设备。 aural 语音合成器。 braille 盲文反馈装置。 handheld 手持设备（小屏幕、有限的带宽）。 projection 投影机。 print 打印预览模式/打印页。 screen 计算机屏幕。 tty 电传打字机以及类似的使用等宽字符网格的媒介。 tv 电视类型设备（低分辨率、有限的滚屏能力）。 属性值 值 描述 width 规定目标显示区域的宽度。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (min-width:500px)&quot; height 规定目标显示区域的高度。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (max-height:700px)&quot; device-width 规定目标显示器/纸张的宽度。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (device-width:500px)&quot; device-height 规定目标显示器/纸张的高度。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (device-height:500px)&quot; orientation 规定目标显示器/纸张的方向。可能的值：”portrait” or “landscape”例子：media=&quot;all and (orientation: landscape)&quot; aspect-ratio 规定目标显示区域的宽度/高度比可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (aspect-ratio:16/9)&quot; device-aspect-ratio 规定目标显示器/纸张的 device-width/device-height 比率可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (aspect-ratio:16/9)&quot; color 规定目标显示器的 bits/color。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (color:3)&quot; color-index 规定目标显示器可以处理的颜色数。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (min-color-index:256)&quot; monochrome 规定单色帧缓冲中的 bits/pixel。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;screen and (monochrome:2)&quot; resolution 规定目标显示器/纸张的像素密度 (dpi 或 dpcm)。可使用 “min-“ 和 “max-“ 前缀。例子：media=&quot;print and (resolution:300dpi)&quot; scan 规定 tv 显示器的扫描方式。可能的值：”progressive” 和 “interlace”。例子：media=&quot;tv and (scan:interlace)&quot; grid 规定输出设备是否是网格或位图。可能的值：”1” 为网格，否则为 “0”。例子：media=&quot;handheld and (grid:1)&quot; 12&lt;!-- 表示在宽度大于768px的屏幕设备上应用该样式，其他媒体类型无效 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"sheet1.css\" media=\"screen and (min-width:768px)\"&gt; @import@import指令用来从外部加载样式文件，类似link标签，但是和link标签还是有很多区别的。1234567/* 以下三种方式都是正确的，相对路径和绝对路径都可以*//* 1 */@import url(sheet2.css);/* 2 */@import url(\"sheet2.css\");/* 3 */@import sheet2.css; @import指令只能用于style标签内或者css样式文件中，并且必须出现在其他的css规则之前，否则浏览器可能会忽略@import指令。1234html &#123; font-size: 14px;&#125;@import url(index02.css); 上面代码中@import指令将会被忽略。 只要是通过@import指令正确导入的外部样式表都会加载，无法指定候选样式表，但是可以指定media媒体类型，直接在后面添加查询条件即可。1@import url(index02.css) screen and (min-width:768px); link和@import的区别 最主要的区别在于lin是属于XHTML标签，除了可以引用样式文件，还可以引用icon等资源，详见rel属性，而@import则是css2.1中的语法特性，只能引用css 加载顺序不同，link加载的css时，是一种并行加载CSS方式，而@import则在整个页面加载完成后才加载 兼容性的区别，@import是CSS2.1才特有的，部分浏览器不支持 link标签可以通过javascript控制，而@import不能 关于样式的引用基本学习到这里，可以参照W3C官网和W3School网站进行更扩展深入的学习。下一篇就主要描述CSS的选择器吧。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://www.betterliyu.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.betterliyu.site/tags/CSS/"}]},{"title":"bwidget-timespinner配置文档","slug":"bwidget-timespinner配置文档","date":"2017-11-02T08:49:01.000Z","updated":"2018-05-29T02:18:11.484Z","comments":true,"path":"2017/11/02/bwidget-timespinner配置文档/","link":"","permalink":"http://www.betterliyu.site/2017/11/02/bwidget-timespinner配置文档/","excerpt":"","text":"bwidget-timespinner 这是一个使用原生javascript开发的时间微调控件，可以分别调节时分秒，并且兼容了中文输入法，限制输入非数字。兼容IE9以上浏览器。 npm: https://www.npmjs.com/package/bwidget-timespinner github: https://github.com/betterliyu/timespinner 安装 npm安装1npm install bwidget-timespinner --save 浏览器直接引用 1234&lt;!-- style --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/bwidget.timespinner.css\"&gt;&lt;!-- script --&gt;&lt;script src=\"js/bwidget.timespinner.js\"&gt;&lt;/script&gt; 可以通过github进行下载：https://github.com/betterliyu/timespinner 使用 初始化 模块化开发 1234567891011121314151617import 'node_modules/bwidget-timespinner/dist/css/bwidget.timespinner.css'import TimeSpinner from 'bwidget-timespinner' var timespinner = new TimeSpinner('#timespinner', &#123; width: 300, height: 40, align: 'center', format: 'hh:mm:ss', second: 1000, disabled: false, onInput (obj) &#123; console.log(obj.preValue + ' - ' + obj.newValue) &#125;, onValueChanged (obj) &#123; console.log(obj.preValue + ' - ' + obj.newValue) &#125;&#125;) 全局变量方式 12// bwidget是全局变量var timespinner = new bwidget.timespinner('#timespinner', &#123;&#125;) 获取和设置 获取属性： var value = instance.prop 设置属性： instance.prop = value 配置说明属性align Type: StringDefault Value: &#39;left&#39;Accept Values: css text-align value 获取或设置控件的内容水平对齐方式。 12345var instance = new TimePicker('#tp', &#123;&#125;)// setinstance.align = 'right'// getvar textAlign = instance.align disabled Type: BooleanDefault Value: false 设置或获取控件是否可用。 12345var instance = new TimePicker('#tp', &#123;&#125;)// setinstance.disabled = true// getvar disabled = instance.disabled element Type: ElementReadOnly 获取控件对应的DOM Element对象。 123var instance = new TimePicker('#tp', &#123;&#125;)// getvar element = instance.element format Type: StringDefault Value: &#39;hh:mm:ss&#39;Accepted Values: &#39;hh:mm:ss&#39; | &#39;hh:mm&#39; | &#39;mm:ss&#39; | &#39;hh(max):mm:ss&#39; | &#39;hh(max):mm&#39; | &#39;mm(max):ss&#39; 设置时间的格式。只能在初始化时设置。分为两种格式，不包含数字，表示采用默认大小，包含数字，表示设置最大小时或分钟数。最大值可以是任意数字。如果未指定则小时最大值为23(&#39;hh(23):mm:ss&#39;,&#39;hh(23):mm&#39;)，分钟最大值为59(&#39;mm(59):ss&#39;)。 123456var instance = new TimePicker('#tp', &#123; // set format: 'hh(99):mm:ss'&#125;)// getvar format = instance.format height Type: String | NumberDefault Value: &#39;100%&#39;Accepted Values: css value | number 设置或获取控件的高度。 12345var instance = new TimePicker('#tp', &#123;&#125;)// setinstance.height = 200// getvar height = instance.height second Type: IntegerDefault Value: 0 设置或获取时间的值。不同格式的时间都通过设置的秒进行转换。 12345var instance = new TimePicker('#tp', &#123;&#125;)// setinstance.second = 1000// getvar sec = instance.second width Type: String | NumberDefault Value: &#39;100%&#39;Accepted Values: css value | number 设置或获取控件的宽度。 12345var instance = new TimePicker('#tp', &#123;&#125;)// setinstance.width = 200// getvar width = instance.width 事件input Type: functionArguments: [Object] { preValue, newValue } 在控件的值被输入或点击上下箭头修改时触发。随后会触发onValueChanged事件 123var instance = new TimePicker('#tp', &#123; onInput: function(arg) &#123; &#125;&#125;) valueChangedv1.0.1 Type: functionArguments: [Object] { preValue, newValue } 在控件的second值发生变化时触发。 123var instance = new TimePicker('#tp', &#123; onValueChanged: function(arg) &#123; &#125;&#125;) 方法text2Second Arguments: Time Format String(控件定义的格式)Return Value: second 将时间字符串转换为对应的秒数。 second2Text Arguments: secondReturn Value: Time Format String(控件定义的格式) 将秒数转换为对应的时间字符串。","categories":[{"name":"个人项目","slug":"个人项目","permalink":"http://www.betterliyu.site/categories/个人项目/"}],"tags":[{"name":"timespinner","slug":"timespinner","permalink":"http://www.betterliyu.site/tags/timespinner/"}]},{"title":"AngularJS学习笔记：Provider和Service","slug":"AngularJS学习笔记-Provider和Service","date":"2017-07-15T09:13:34.000Z","updated":"2018-05-29T02:18:11.469Z","comments":true,"path":"2017/07/15/AngularJS学习笔记-Provider和Service/","link":"","permalink":"http://www.betterliyu.site/2017/07/15/AngularJS学习笔记-Provider和Service/","excerpt":"","text":"基本概念依赖注入是AngularJS的四大特性之一，在理解AngularJS如果实现依赖注入之前需要知道一些名词概念。 Service（服务）服务是一些公共代码的集合（常量，变量，方法或对象），可以在控制器、指令等地方注入并使用。我们可以把控制器中重复的代码抽象成一个个服务的方法，通过服务来调用。AngularJS有许多内置的服务，比如$http服务提供ajax的操作，$filter提供数据过滤的操作等等。应用程序中所有服务保存在内部变量instanceCache中。关于Service有一下几点需要注意： Service是单例的； Service由内部的$injector进行实例化，不需要手动实例化； 所有的Service都是保存在一个对象中，内置服务都以$开头，所以自定义服务不要以$开头，并且不要同名，否则会发生覆盖的情况，在使用第三方库的时候尤其要注意； Service不能注入到config配置块中，配置块中只能注入供应商。 Provider（供应商）供应商用来向控制器，指令等提供服务。供应商在定义时会包含一个服务在函数内，AngularJS实例化供应商内部的服务，将其保存在变量中，之后需要注入服务时只需要到变量中获取。 AngularJS提供了一个内置对象$provider，这个对象上有5个属性方法： provide，factory，service，value，constant和decorator。其中前面4个都是用来创建provider的，只不过是不同写法而已。constant用来创建一个常量，decorator用来对其他服务做一些装饰修改。AngularJS也在模块对象上挂在了这几个相同的方法，就是说我们创建一个供应商或服务可以这样写： 1234angular .module('app') .provide(...) .factory(...) 应用程序中所有供应商保存在内部变量providerCache中。关于Provider有一下几点需要注意： Provider只能注入到config配置块中，在配置块中可以对服务进行最后的修改； 注入的时候需要在定义的服务名称后面加上Provider，完整的供应商的名称是serviceProvider。 $Injector（注入器）$injector是实现依赖注入的关键。他是一个内置的服务，提供以下几个方法： annotate 解析参数列表 invoke 调用函数（会自动注入依赖的服务或供应商） instantiate 实例化对象（会自动注入依赖的服务或供应商） get 获取实例（不存在实例则创建） has 判断服务是否已经创建 $injector是通过createInternalInjector方法创建的，在AngularJS内部还通过这个方法创建了两个关键的对象providerInjector和instanceInjector。$injector就是instanceInjector，用来操作服务，但是$injector可以被我们调用，用来处理其他的函数，比如annotate，invoke和instantiate，可以对普通的函数操作；providerInjector用来操作供应商。get方法就是从对应的变量（instanceCache或者providerCache）中获取实例。 Provider用法上面说过$provide提供多种创建供应商的方法，但是原理都是一样，只是语法糖而已（constant和decorator除外，需要单独讨论），而这些方法都挂在在了module对象上了，所以我这里只讨论moudule.provider方法。 provider方法用法如下： 1234567891011121314151617181920212223angular .module('app') .provider('freeball', function freeballProvider () &#123; var freeballFlag = false; this.setFreeball = function (value) &#123; freeballFlag = !!value; &#125;; // 必须有这个方法 this.$get = function freeballFactory() &#123; return &#123; freeball: freeballFlag &#125; &#125;; &#125;) .config(function(freeballProvider)&#123; console.log('我是提供者'); freeballProvider.setFreeball(true) console.dir(freeballProvider) &#125;) .controller('homeController', function (freeball) &#123; console.log('我是服务'); console.dir(freeball) &#125;); 查看输出结果你会发现： config中的freeballProvider好像是 freeballProvider函数生成的，他只有在this上面绑定的两个函数setFreeball和$get controller中的freeball好像是freeballFactory函数返回的对象，而且属性freeball的值不是false而是true 实际上，这就是Provider的含义： 它通过provider方法传入的两个参数，生成了一个带有$get方法的对象，这个对象就是供应商，他可以注入到config配置块中(只有provider和constant创建的供应商可以注入到config中)，对内部的变量做一些修改，这里我们把freeballFlag改成了true。 在控制器，指令等需要注入服务的方法执行之前AngularJS会注入它们需要的服务，这些服务当然就是通过调用供应商的$get方法生成的了，而且只会生成一次，在不同地方注入的相同服务是同一实例。 所以供应商创建服务的关键就是this.$get方法，他被用来调用返回他的返回值，这个返回值就是服务。其他几种创建服务的方法都会在内部添加上$get方法，然后调用provider。下面我们就会来研究以下源码，看看如何调用$get方法，如何实例化并注入到方法中的。 源码解析可以看一下源代码，看一下AngularJS是如何创建供应商 createInternalInjector方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// 以下是调用createInternalInjector创建注入器的过程，两个注入器都会返回相同结构的对象，// 但是由于内部返回的方法都是闭包，所以他们是对不同cache进行操作的。// 可以看出分别是providerCache和instanceCache，两次调用传入的工厂方法也是不一样的。providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) &#123; if (angular.isString(caller)) &#123; path.push(caller); &#125; throw $injectorMinErr('unpr', 'Unknown provider: &#123;0&#125;', path.join(' &lt;- ')); &#125;)),instanceCache = &#123;&#125;,protoInstanceInjector = // 这里传入的工厂方法会根据对应供应商调用get方法返回服务 createInternalInjector(instanceCache, function(serviceName, caller) &#123; var provider = providerInjector.get(serviceName + providerSuffix, caller); return instanceInjector.invoke( provider.$get, provider, undefined, serviceName); &#125;),instanceInjector = protoInstanceInjector;function createInternalInjector(cache, factory) &#123; // 这是获取服务的方法 function getService(serviceName, caller) &#123; if (cache.hasOwnProperty(serviceName)) &#123; if (cache[serviceName] === INSTANTIATING) &#123; throw $injectorMinErr('cdep', 'Circular dependency found: &#123;0&#125;', serviceName + ' &lt;- ' + path.join(' &lt;- ')); &#125; // 如果已经有了直接返回 return cache[serviceName]; &#125; else &#123; try &#123; path.unshift(serviceName); cache[serviceName] = INSTANTIATING; // 如果没有调用工厂方法创建，这个工厂方法就是调用两次createInternalInjector方法创建 // providerInjector和instanceInjector时传入的方法。创建服务的过程就在第二次调用的方法中。 cache[serviceName] = factory(serviceName, caller); return cache[serviceName]; &#125; catch (err) &#123; if (cache[serviceName] === INSTANTIATING) &#123; delete cache[serviceName]; &#125; throw err; &#125; finally &#123; path.shift(); &#125; &#125; &#125; // 这是注入参数的方法 function injectionArgs(fn, locals, serviceName) &#123; var args = [], // 解析参数列表 $inject = createInjector.$$annotate(fn, strictDi, serviceName); for (var i = 0, length = $inject.length; i &lt; length; i++) &#123; var key = $inject[i]; if (typeof key !== 'string') &#123; throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got &#123;0&#125;', key); &#125; // getService获取服务并添加到参数列表 args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName)); &#125; return args; &#125; function invoke(fn, self, locals, serviceName) &#123; if (typeof locals === 'string') &#123; serviceName = locals; locals = null; &#125; var args = injectionArgs(fn, locals, serviceName); if (isArray(fn)) &#123; fn = fn[fn.length - 1]; &#125; if (!isClass(fn)) &#123; // http://jsperf.com/angularjs-invoke-apply-vs-switch // #5388 return fn.apply(self, args); &#125; else &#123; args.unshift(null); return new (Function.prototype.bind.apply(fn, args))(); &#125; &#125; // 这是实例化供应商的方法 function instantiate(Type, locals, serviceName) &#123; var ctor = (isArray(Type) ? Type[Type.length - 1] : Type); // 注入参数 var args = injectionArgs(Type, locals, serviceName); args.unshift(null); // 这里用了new操作符创建了供应商，所以我们看到freeballProvider对象上面只有绑定到this上的方法 return new (Function.prototype.bind.apply(ctor, args))(); &#125; return &#123; invoke: invoke, instantiate: instantiate, get: getService, annotate: createInjector.$$annotate, has: function(name) &#123; return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name); &#125; &#125;;&#125; 供应商实例创建过程1234567891011121314// 这是provider方法function provider(name, provider_) &#123; assertNotHasOwnProperty(name, 'service'); if (isFunction(provider_) || isArray(provider_)) &#123; // 这里调用instantiate方法来生成供应商Provider provider_ = providerInjector.instantiate(provider_); &#125; if (!provider_.$get) &#123; throw $injectorMinErr('pget', \"Provider '&#123;0&#125;' must define $get factory method.\", name); &#125; // 这里将你定义的名字加上“Provider”后缀，然后将生成的provider_添加到一个缓存对象中 // 所以其实我们创建的freeball供应商其实被保存成了freeballProvider，放在provideCache中 return providerCache[name + providerSuffix] = provider_;&#125; 服务实例创建过程12345678910111213141516171819// 我这里只以控制器为例// 这是初始化控制器对象的代码function $controllerInit() &#123; // 这里调用了$injector.invoke，通过调试，结合invoke方法的内部实现，不难发现angularjs在调用控制 // 器之前，对参数进行了解析和实例化，最后注入到函数中，同时保存在了cache中，以保证下次注入不需 // 要重新创建 var result = $injector.invoke(expression, instance, locals, constructor); if (result !== instance &amp;&amp; (isObject(result) || isFunction(result))) &#123; instance = result; if (identifier) &#123; // If result changed, re-assign controllerAs value to scope. addIdentifier(locals, identifier, instance, constructor || expression.name); &#125; &#125; return instance;&#125;, &#123; instance: instance, identifier: identifier&#125; 以上只是创建供应商和服务大概流程。需要好好的研究源码的结构和调用栈才能理解它的执行过程。当然不排除我有可能理解错误，仅供参考。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.betterliyu.site/categories/JavaScript/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.betterliyu.site/tags/AngularJS/"}]}]}